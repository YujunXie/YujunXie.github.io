---
title: 关联规则之FP-Growth算法
key: 20161125
tags: 数据挖掘
---

Fp-growth算法相比于Aprior的优势就是不用生成大量的**候选项集。**

它使用的是FP-tree(Frequent-Pattern tree)结构压缩数据库，避免对数据库的冗余扫描。
采用分而治之的方法学：分解数据挖掘任务为小任务。

总体分为三个步骤：

 1. 建立头表和FP-tree
 2. 挖掘FP-tree
 3. 生成频繁项集

理解后两个递归步骤：将压缩后的数据库(FP-tree)划分成一组条件数据库，每个数据库关联一个频繁项，并分别挖掘每个条件数据库。

<!--more-->

 1. **建立FP-tree**：

FP-tree是一棵前缀树，按支持度降序排列，支持度越高的频繁项离根节点越近，从而使得更多的频繁项可以共享前缀。

优点：

- 完备（不会打破交易中的任何模式；包含了序列模式挖掘所需的全部信息)
- 紧密（去除不相关信息—不包含非频繁项；支持度降序排列: 支持度高的项在FP-tree中共享的机会也高；公共项的重叠大大压缩存储了原数据库）
	
*建立前：*

1. 扫描数据库一次，得到频繁1-项集F1。
2. 建立一张项的头表HeadTable，项域信息：频繁项，该项支持度，该项在FP-tree中节点位置的指针。且头表按频繁项的支持度递减排序。

*建立：*
FP-tree的节点：

    class TreeNode {
       private:
	    String name; // 节点名称
	    int count; // 支持度计数
	    TreeNode *parent; // 父节点
	    Vector<TreeNode *> children; // 子节点
	    TreeNode *nextHomonym; // 指向同名节点
	    
	    ...
    }

1. 创建树的根节点，标记null。
2. 最后一次扫描数据库，按照F1中的顺序重新排序，并删除频数小于最小支持度的商品。
3. 为每个事务创建一个分支，若节点或分支存在，则共享，同时将共享前缀上每个节点的计数加一，为前缀之后的项创建节点和链接。若不存在，则以根节点为父节点将该事务中的项按照F1中的次序依次插入。

![图片1.png](https://i.loli.net/2018/08/16/5b75258b24482.png)

 - **挖掘FP-tree，生成频繁项集**

1. 为FP-tree中的每个节点生成条件模式库

	从FP-tree的头表开始，按照每个频繁项的连接向上遍历FP-tree，列出能够到达此项的所有前缀路径，对于每一条路径上的节点，其计数都设置为此项的计数，得到条件模式库。

	![图片2.png](https://i.loli.net/2018/08/16/5b75258b0ad3a.png)

	可以发现，每个项的条件模式库又构成了一个事务数据库。
 
2. 用条件模式库构建对应的条件FP-tree

	![图片3.png](https://i.loli.net/2018/08/16/5b75258b0cd34.png)

3. 递归构造条件FP-trees，同时增长其包含的频繁集。如果条件FP-tree只包含一个路径(此路径的每个子路径对应的项集都是频繁模式)，则直接生成所包含的频繁集。

	当遇到一个FP-tree有一个共享唯一前缀路径：

	![图片4.png](https://i.loli.net/2018/08/16/5b75258b25f3a.png)



> FpGrowth算法的平均效率远高于Apriori算法，但是它并不能保证高效率，它的效率依赖于数据集，当数据集中的频繁项集的没有公共项时，所有的项集都挂在根结点上，不能实现压缩存储，而且Fp-tree还需要其他的开销，需要存储空间更大，使用FpGrowth算法前，对数据分析一下，看是否适合用FpGrowth算法。
